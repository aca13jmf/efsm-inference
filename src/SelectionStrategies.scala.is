object Fun {

def id[A]: A => A = ((x: A) => x)

def comp[A, B, C](f: A => B, g: C => A): C => B = ((x: C) => f(g(x)))

} /* object Fun */

object HOL {

trait equal[A] {
  val `HOL.equal`: (A, A) => Boolean
}
def equal[A](a: A, b: A)(implicit A: equal[A]): Boolean = A.`HOL.equal`(a, b)
object equal {
  implicit def
    `Transition.equal_transition_ext`[A : equal]:
      equal[Transition.transition_ext[A]]
    = new equal[Transition.transition_ext[A]] {
    val `HOL.equal` =
      (a: Transition.transition_ext[A], b: Transition.transition_ext[A]) =>
      Transition.equal_transition_exta[A](a, b)
  }
  implicit def `Product_Type.equal_unit`: equal[Unit] = new equal[Unit] {
    val `HOL.equal` = (a: Unit, b: Unit) => Product_Type.equal_unita(a, b)
  }
  implicit def `Product_Type.equal_prod`[A : equal, B : equal]: equal[(A, B)] =
    new equal[(A, B)] {
    val `HOL.equal` = (a: (A, B), b: (A, B)) =>
      Product_Type.equal_proda[A, B](a, b)
  }
  implicit def `VName.equal_vname`: equal[VName.vname] = new equal[VName.vname]
    {
    val `HOL.equal` = (a: VName.vname, b: VName.vname) =>
      VName.equal_vnamea(a, b)
  }
  implicit def `String.equal_char`: equal[String.char] = new equal[String.char]
    {
    val `HOL.equal` = (a: String.char, b: String.char) =>
      String.equal_chara(a, b)
  }
  implicit def `GExp.equal_gexp`: equal[GExp.gexp] = new equal[GExp.gexp] {
    val `HOL.equal` = (a: GExp.gexp, b: GExp.gexp) => GExp.equal_gexpa(a, b)
  }
  implicit def `AExp.equal_aexp`: equal[AExp.aexp] = new equal[AExp.aexp] {
    val `HOL.equal` = (a: AExp.aexp, b: AExp.aexp) => AExp.equal_aexpa(a, b)
  }
}

def eq[A : equal](a: A, b: A): Boolean = equal[A](a, b)

} /* object HOL */

object Groups {

trait plus[A] {
  val `Groups.plus`: (A, A) => A
}
def plus[A](a: A, b: A)(implicit A: plus[A]): A = A.`Groups.plus`(a, b)
object plus {
  implicit def `Nat.plus_nat`: plus[Nat.nat] = new plus[Nat.nat] {
    val `Groups.plus` = (a: Nat.nat, b: Nat.nat) => Nat.plus_nata(a, b)
  }
}

trait semigroup_add[A] extends plus[A] {
}
object semigroup_add {
  implicit def `Nat.semigroup_add_nat`: semigroup_add[Nat.nat] = new
    semigroup_add[Nat.nat] {
    val `Groups.plus` = (a: Nat.nat, b: Nat.nat) => Nat.plus_nata(a, b)
  }
}

trait zero[A] {
  val `Groups.zero`: A
}
def zero[A](implicit A: zero[A]): A = A.`Groups.zero`
object zero {
  implicit def `Nat.zero_nat`: zero[Nat.nat] = new zero[Nat.nat] {
    val `Groups.zero` = Nat.zero_nata
  }
}

trait monoid_add[A] extends semigroup_add[A] with zero[A] {
}
object monoid_add {
  implicit def `Nat.monoid_add_nat`: monoid_add[Nat.nat] = new
    monoid_add[Nat.nat] {
    val `Groups.zero` = Nat.zero_nata
    val `Groups.plus` = (a: Nat.nat, b: Nat.nat) => Nat.plus_nata(a, b)
  }
}

trait ab_semigroup_add[A] extends semigroup_add[A] {
}
object ab_semigroup_add {
  implicit def `Nat.ab_semigroup_add_nat`: ab_semigroup_add[Nat.nat] = new
    ab_semigroup_add[Nat.nat] {
    val `Groups.plus` = (a: Nat.nat, b: Nat.nat) => Nat.plus_nata(a, b)
  }
}

trait comm_monoid_add[A] extends ab_semigroup_add[A] with monoid_add[A] {
}
object comm_monoid_add {
  implicit def `Nat.comm_monoid_add_nat`: comm_monoid_add[Nat.nat] = new
    comm_monoid_add[Nat.nat] {
    val `Groups.zero` = Nat.zero_nata
    val `Groups.plus` = (a: Nat.nat, b: Nat.nat) => Nat.plus_nata(a, b)
  }
}

} /* object Groups */

object Num {

abstract sealed class num
final case class One() extends num
final case class Bit0(a: num) extends num
final case class Bit1(a: num) extends num

} /* object Num */

object Nat {

abstract sealed class nat
final case class Nata(a: BigInt) extends nat

def plus_nata(m: nat, n: nat): nat =
  Nata(Code_Numeral.integer_of_nat(m) + Code_Numeral.integer_of_nat(n))

def zero_nata: nat = Nata(BigInt(0))

def one_nat: nat = Nata(BigInt(1))

def Suc(n: nat): nat = plus_nata(n, one_nat)

def equal_nat(m: nat, n: nat): Boolean =
  Code_Numeral.integer_of_nat(m) == Code_Numeral.integer_of_nat(n)

} /* object Nat */

object Code_Numeral {

def integer_of_nat(x0: Nat.nat): BigInt = x0 match {
  case Nat.Nata(x) => x
}

def integer_of_int(x0: Int.int): BigInt = x0 match {
  case Int.int_of_integer(k) => k
}

} /* object Code_Numeral */

object Int {

abstract sealed class int
final case class int_of_integer(a: BigInt) extends int

def equal_int(k: int, l: int): Boolean =
  Code_Numeral.integer_of_int(k) == Code_Numeral.integer_of_int(l)

} /* object Int */

object Lista {

def maps[A, B](f: A => List[B], x1: List[A]): List[B] = (f, x1) match {
  case (f, Nil) => Nil
  case (f, x :: xs) => f(x) ++ maps[A, B](f, xs)
}

def foldr[A, B](f: A => B => B, x1: List[A]): B => B = (f, x1) match {
  case (f, Nil) => Fun.id[B]
  case (f, x :: xs) => Fun.comp[B, B, B](f(x), foldr[A, B](f, xs))
}

def filter[A](p: A => Boolean, x1: List[A]): List[A] = (p, x1) match {
  case (p, Nil) => Nil
  case (p, x :: xs) => (if (p(x)) x :: filter[A](p, xs) else filter[A](p, xs))
}

def member[A : HOL.equal](x0: List[A], y: A): Boolean = (x0, y) match {
  case (Nil, y) => false
  case (x :: xs, y) => (HOL.eq[A](x, y)) || (member[A](xs, y))
}

def remdups[A : HOL.equal](x0: List[A]): List[A] = x0 match {
  case Nil => Nil
  case x :: xs =>
    (if (member[A](xs, x)) remdups[A](xs) else x :: remdups[A](xs))
}

def map[A, B](f: A => B, x1: List[A]): List[B] = (f, x1) match {
  case (f, Nil) => Nil
  case (f, x21 :: x22) => f(x21) :: map[A, B](f, x22)
}

def equal_list[A : HOL.equal](x0: List[A], x1: List[A]): Boolean = (x0, x1)
  match {
  case (Nil, x21 :: x22) => false
  case (x21 :: x22, Nil) => false
  case (x21 :: x22, y21 :: y22) =>
    (HOL.eq[A](x21, y21)) && (equal_list[A](x22, y22))
  case (Nil, Nil) => true
}

} /* object Lista */

object Set {

abstract sealed class set[A]
final case class seta[A](a: List[A]) extends set[A]
final case class coset[A](a: List[A]) extends set[A]

def filter[A](p: A => Boolean, x1: set[A]): set[A] = (p, x1) match {
  case (p, seta(xs)) => seta[A](Lista.filter[A](p, xs))
}

} /* object Set */

object Product_Type {

def equal_proda[A : HOL.equal, B : HOL.equal](x0: (A, B), x1: (A, B)): Boolean =
  (x0, x1) match {
  case ((x1, x2), (y1, y2)) => (HOL.eq[A](x1, y1)) && (HOL.eq[B](x2, y2))
}

def equal_unita(u: Unit, v: Unit): Boolean = true

def product[A, B](x0: Set.set[A], x1: Set.set[B]): Set.set[(A, B)] = (x0, x1)
  match {
  case (Set.seta(xs), Set.seta(ys)) =>
    Set.seta[(A, B)](Lista.maps[A, (A, B)](((x: A) =>
     Lista.map[B, (A, B)](((a: B) => (x, a)), ys)),
    xs))
}

def equal_bool(p: Boolean, pa: Boolean): Boolean = (p, pa) match {
  case (p, true) => p
  case (p, false) => ! p
  case (true, p) => p
  case (false, p) => ! p
}

} /* object Product_Type */

object String {

abstract sealed class char
final case class
  Char(a: Boolean, b: Boolean, c: Boolean, d: Boolean, e: Boolean, f: Boolean,
        g: Boolean, h: Boolean)
  extends char

def equal_chara(x0: char, x1: char): Boolean = (x0, x1) match {
  case (Char(x1, x2, x3, x4, x5, x6, x7, x8),
         Char(y1, y2, y3, y4, y5, y6, y7, y8))
    => (Product_Type.equal_bool(x1, y1)) && ((Product_Type.equal_bool(x2,
                               y2)) && ((Product_Type.equal_bool(x3,
                          y3)) && ((Product_Type.equal_bool(x4,
                     y4)) && ((Product_Type.equal_bool(x5,
                y5)) && ((Product_Type.equal_bool(x6,
           y6)) && ((Product_Type.equal_bool(x7,
      y7)) && (Product_Type.equal_bool(x8, y8))))))))
}

} /* object String */

object Value {

abstract sealed class value
final case class Numa(a: Int.int) extends value
final case class Str(a: List[String.char]) extends value

def equal_value(x0: value, x1: value): Boolean = (x0, x1) match {
  case (Numa(x1), Str(x2)) => false
  case (Str(x2), Numa(x1)) => false
  case (Str(x2), Str(y2)) => Lista.equal_list[String.char](x2, y2)
  case (Numa(x1), Numa(y1)) => Int.equal_int(x1, y1)
}

} /* object Value */

object VName {

abstract sealed class vname
final case class I(a: Nat.nat) extends vname
final case class R(a: Nat.nat) extends vname

def equal_vnamea(x0: vname, x1: vname): Boolean = (x0, x1) match {
  case (I(x1), R(x2)) => false
  case (R(x2), I(x1)) => false
  case (R(x2), R(y2)) => Nat.equal_nat(x2, y2)
  case (I(x1), I(y1)) => Nat.equal_nat(x1, y1)
}

} /* object VName */

object AExp {

abstract sealed class aexp
final case class L(a: Value.value) extends aexp
final case class V(a: VName.vname) extends aexp
final case class Plus(a: aexp, b: aexp) extends aexp
final case class Minus(a: aexp, b: aexp) extends aexp

def equal_aexpa(x0: aexp, x1: aexp): Boolean = (x0, x1) match {
  case (Plus(x31, x32), Minus(x41, x42)) => false
  case (Minus(x41, x42), Plus(x31, x32)) => false
  case (V(x2), Minus(x41, x42)) => false
  case (Minus(x41, x42), V(x2)) => false
  case (V(x2), Plus(x31, x32)) => false
  case (Plus(x31, x32), V(x2)) => false
  case (L(x1), Minus(x41, x42)) => false
  case (Minus(x41, x42), L(x1)) => false
  case (L(x1), Plus(x31, x32)) => false
  case (Plus(x31, x32), L(x1)) => false
  case (L(x1), V(x2)) => false
  case (V(x2), L(x1)) => false
  case (Minus(x41, x42), Minus(y41, y42)) =>
    (equal_aexpa(x41, y41)) && (equal_aexpa(x42, y42))
  case (Plus(x31, x32), Plus(y31, y32)) =>
    (equal_aexpa(x31, y31)) && (equal_aexpa(x32, y32))
  case (V(x2), V(y2)) => VName.equal_vnamea(x2, y2)
  case (L(x1), L(y1)) => Value.equal_value(x1, y1)
}

} /* object AExp */

object Groups_List {

def sum_list[A : Groups.monoid_add](xs: List[A]): A =
  (Lista.foldr[A, A](((a: A) => (b: A) => Groups.plus[A](a, b)),
                      xs)).apply(Groups.zero[A])

} /* object Groups_List */

object Groups_Big {

def sum[A : HOL.equal, B : Groups.comm_monoid_add](g: A => B, x1: Set.set[A]): B
  =
  (g, x1) match {
  case (g, Set.seta(xs)) =>
    Groups_List.sum_list[B](Lista.map[A, B](g, Lista.remdups[A](xs)))
}

} /* object Groups_Big */

object FSet {

abstract sealed class fset[A]
final case class Abs_fset[A](a: Set.set[A]) extends fset[A]

def fset[A](x0: fset[A]): Set.set[A] = x0 match {
  case Abs_fset(x) => x
}

def ffilter[A](xb: A => Boolean, xc: fset[A]): fset[A] =
  Abs_fset[A](Set.filter[A](xb, fset[A](xc)))

def size_fset[A : HOL.equal](x: A => Nat.nat, xc: fset[A]): Nat.nat =
  Groups_Big.sum[A, Nat.nat](Fun.comp[Nat.nat, Nat.nat,
                                       A](((a: Nat.nat) => Nat.Suc(a)), x),
                              fset[A](xc))

def size_fseta[A : HOL.equal]: (fset[A]) => Nat.nat =
  ((a: fset[A]) => size_fset[A](((_: A) => Nat.zero_nata), a))

} /* object FSet */

object GExp {

abstract sealed class gexp
final case class Bc(a: Boolean) extends gexp
final case class Eq(a: AExp.aexp, b: AExp.aexp) extends gexp
final case class Gt(a: AExp.aexp, b: AExp.aexp) extends gexp
final case class Nor(a: gexp, b: gexp) extends gexp
final case class Null(a: VName.vname) extends gexp

def equal_gexpa(x0: gexp, x1: gexp): Boolean = (x0, x1) match {
  case (Nor(x41, x42), Null(x5)) => false
  case (Null(x5), Nor(x41, x42)) => false
  case (Gt(x31, x32), Null(x5)) => false
  case (Null(x5), Gt(x31, x32)) => false
  case (Gt(x31, x32), Nor(x41, x42)) => false
  case (Nor(x41, x42), Gt(x31, x32)) => false
  case (Eq(x21, x22), Null(x5)) => false
  case (Null(x5), Eq(x21, x22)) => false
  case (Eq(x21, x22), Nor(x41, x42)) => false
  case (Nor(x41, x42), Eq(x21, x22)) => false
  case (Eq(x21, x22), Gt(x31, x32)) => false
  case (Gt(x31, x32), Eq(x21, x22)) => false
  case (Bc(x1), Null(x5)) => false
  case (Null(x5), Bc(x1)) => false
  case (Bc(x1), Nor(x41, x42)) => false
  case (Nor(x41, x42), Bc(x1)) => false
  case (Bc(x1), Gt(x31, x32)) => false
  case (Gt(x31, x32), Bc(x1)) => false
  case (Bc(x1), Eq(x21, x22)) => false
  case (Eq(x21, x22), Bc(x1)) => false
  case (Null(x5), Null(y5)) => VName.equal_vnamea(x5, y5)
  case (Nor(x41, x42), Nor(y41, y42)) =>
    (equal_gexpa(x41, y41)) && (equal_gexpa(x42, y42))
  case (Gt(x31, x32), Gt(y31, y32)) =>
    (AExp.equal_aexpa(x31, y31)) && (AExp.equal_aexpa(x32, y32))
  case (Eq(x21, x22), Eq(y21, y22)) =>
    (AExp.equal_aexpa(x21, y21)) && (AExp.equal_aexpa(x22, y22))
  case (Bc(x1), Bc(y1)) => Product_Type.equal_bool(x1, y1)
}

} /* object GExp */

object FSet_Utils {

def fprod[A, B](xb: FSet.fset[A], xc: FSet.fset[B]): FSet.fset[(A, B)] =
  FSet.Abs_fset[(A, B)](Product_Type.product[A,
      B](FSet.fset[A](xb), FSet.fset[B](xc)))

} /* object FSet_Utils */

object Transition {

abstract sealed class transition_ext[A]
final case class
  transition_exta[A](a: List[String.char], b: Nat.nat, c: List[GExp.gexp],
                      d: List[AExp.aexp], e: List[(VName.vname, AExp.aexp)],
                      f: A)
  extends transition_ext[A]

def equal_transition_exta[A : HOL.equal](x0: transition_ext[A],
  x1: transition_ext[A]):
      Boolean
  =
  (x0, x1) match {
  case (transition_exta(labela, aritya, guarda, outputsa, updatesa, morea),
         transition_exta(label, arity, guard, outputs, updates, more))
    => (Lista.equal_list[String.char](labela,
                                       label)) && ((Nat.equal_nat(aritya,
                           arity)) && ((Lista.equal_list[GExp.gexp](guarda,
                             guard)) && ((Lista.equal_list[AExp.aexp](outputsa,
                               outputs)) && ((Lista.equal_list[(VName.vname,
                         AExp.aexp)](updatesa,
                                      updates)) && (HOL.eq[A](morea, more))))))
}

def Arity[A](x0: transition_ext[A]): Nat.nat = x0 match {
  case transition_exta(label, arity, guard, outputs, updates, more) => arity
}

def Label[A](x0: transition_ext[A]): List[String.char] = x0 match {
  case transition_exta(label, arity, guard, outputs, updates, more) => label
}

} /* object Transition */

object SelectionStrategies {

def naive_score(t1: FSet.fset[Transition.transition_ext[Unit]],
                 t2: FSet.fset[Transition.transition_ext[Unit]]):
      Nat.nat
  =
  FSet.size_fseta[(Transition.transition_ext[Unit],
                    Transition.transition_ext[Unit])].apply(FSet.ffilter[(Transition.transition_ext[Unit],
                                   Transition.transition_ext[Unit])](((a:
                                 (Transition.transition_ext[Unit],
                                   Transition.transition_ext[Unit]))
                                =>
                               {
                                 val (x, y):
                                       (Transition.transition_ext[Unit],
 Transition.transition_ext[Unit])
                                   = a;
                                 (Lista.equal_list[String.char](Transition.Label[Unit](x),
                         Transition.Label[Unit](y))) && (Nat.equal_nat(Transition.Arity[Unit](x),
                                Transition.Arity[Unit](y)))
                               }),
                              FSet_Utils.fprod[Transition.transition_ext[Unit],
        Transition.transition_ext[Unit]](t1, t2)))

} /* object SelectionStrategies */
