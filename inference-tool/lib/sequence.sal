sequence {XB : TYPE; xb : XB, max : NATURAL} : CONTEXT =
BEGIN

%% The sequence context, which models Z sequences as total SAL functions
%% from the positive natural numbers to elements, using a bottom element
%% to represent unused indices.  Sequences must be declared with a fixed
%% max length, and use xb as the bottom element.  This context defines only
%% the additional sequence operations; other function and set operations
%% are defined in the function context.

%% A sequence is identical to a function, whose domain type is Index, a
%% subrange from 1..max, and whose range type is XB, which extends the type
%% X with a bottom element xb.

%% Version revised by A J H Simons on 1 September 2011.

%% Local types - do not export; for internal use within this context only.

	Size : TYPE = [0..max];
	Index : TYPE = {x : Size | x /= 0};

	X : TYPE = {x : XB | x /= xb};

	Domain : TYPE = [Index -> BOOLEAN];	%% set{Index;}!Set
	Range : TYPE = [X -> BOOLEAN];		%% set{X;}!Set

	NX : Type = [Index, X];
	Bag : TYPE = [X -> Size];
	Relation : Type = [NX -> BOOLEAN];	%% set{XN;}!Set

%% Exported type - use only if you don't want to apply operations from the
%% function context as well.  If you do, use the base type [Index -> XB].

	Sequence : TYPE = [Index -> XB];

%% Sequence constructors.  An empty sequence is a function where every index
%% maps to the undefined element.  A singleton sequence is one containing
%% exactly one element, at the index 1.

	empty : Sequence = LAMBDA (n : Index) : xb;


%% Calculate the length of a sequence.  This recursive definition seems
%% to succeed because SAL can determine an upper limit to the recursions.

	sizeAux (seq : Sequence, i : Index) : Size =
		IF seq(i) = xb THEN i-1
		ELSIF i = max THEN max
		ELSE sizeAux(seq, i+1) ENDIF;

	size? (seq : Sequence) : Size = sizeAux(seq, 1);

END
